//THIS FILE IS AUTOGENERATED BY GHOSTCOMPILER. DON'T MODIFY OR ALTER.
using Unity.Burst;
using Unity.Burst.Intrinsics;
using System;
using Unity.NetCode.LowLevel.Unsafe;
#region __COMMAND_USING_STATEMENT__
using __COMMAND_USING__;
#endregion

namespace __COMMAND_NAMESPACE__
{
    [DontSupportPrefabOverrides]
    [GhostComponent(SendDataForChildEntity = true)]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public struct __COMMAND_NAME__InputBufferData : IInputBufferData
    {
        [DontSerializeForCommand]
        public NetworkTick Tick { get; set; }
        public __COMMAND_COMPONENT_TYPE__ InternalInput;

        public void DecrementEventsAndAssignToInput(IntPtr prevInputBufferDataPtr, IntPtr inputPtr)
        {
            ref var prevInput = ref GhostComponentSerializer.TypeCast<__COMMAND_NAME__InputBufferData>(prevInputBufferDataPtr);
            ref var input = ref GhostComponentSerializer.TypeCast<__COMMAND_COMPONENT_TYPE__>(inputPtr);
            input = InternalInput;
            #region __DECREMENT_INPUTEVENT__
            input.__EVENTNAME__.Count -= prevInput.InternalInput.__EVENTNAME__.Count;
            #endregion
        }

        public void IncrementEventsAndSetCurrentInputData(IntPtr prevInputBufferDataPtr, IntPtr inputPtr)
        {
            ref var input = ref GhostComponentSerializer.TypeCast<__COMMAND_COMPONENT_TYPE__>(inputPtr);
            ref var lastInput = ref GhostComponentSerializer.TypeCast<__COMMAND_NAME__InputBufferData>(prevInputBufferDataPtr);
            InternalInput = input;
            #region __INCREMENT_INPUTEVENT__
            InternalInput.__EVENTNAME__.Count += lastInput.InternalInput.__EVENTNAME__.Count;
            #endregion
        }
    }

    // Needs to run before GhostAuthoringBakingSystem so the buffer is there before ghost processing
    [UpdateInGroup(typeof(BakingSystemGroup))]
    [WorldSystemFilter(WorldSystemFilterFlags.BakingSystem)]
    [System.Runtime.CompilerServices.CompilerGenerated]
    internal partial class __COMMAND_NAME__InputBufferDataBakingSystem : SystemBase
    {
        EntityQuery m_AddBufferQuery;
        protected override void OnCreate()
        {
            m_AddBufferQuery = GetEntityQuery(
                new EntityQueryDesc
                {
                    All = new[]
                    {
                        ComponentType.ReadOnly<__COMMAND_NAME__>()
                    },
                    None = new []
                    {
                        ComponentType.ReadOnly<__COMMAND_NAME__InputBufferData>()
                    },
                    Options = EntityQueryOptions.IncludeDisabledEntities | EntityQueryOptions.IncludePrefab
                });
            RequireForUpdate(m_AddBufferQuery);
        }

        protected override void OnUpdate()
        {
            var newEntities = m_AddBufferQuery.ToEntityArray(Allocator.Temp);
            for (int i = 0; i < newEntities.Length; ++i)
                EntityManager.AddComponent<__COMMAND_NAME__InputBufferData>(newEntities[i]);
        }
    }

    [BurstCompile]
    [System.Runtime.CompilerServices.CompilerGenerated]
    [UpdateInGroup(typeof(GhostInputSystemGroup), OrderLast = true)]
    [WorldSystemFilter(WorldSystemFilterFlags.ClientSimulation | WorldSystemFilterFlags.ThinClientSimulation)]
    internal partial struct __COMMAND_NAME__CopyInputToCommandBufferSystem : ISystem
    {
        private CopyInputToCommandBuffer<__COMMAND_NAME__InputBufferData, __COMMAND_COMPONENT_TYPE__> m_System;
        private EntityQuery m_EntityQuery;

        [BurstCompile]
        public struct CopyInputs : IJobChunk
        {
            public CopyInputToCommandBuffer<__COMMAND_NAME__InputBufferData, __COMMAND_COMPONENT_TYPE__>.CopyInputToBufferJob Job;
            [BurstCompile]
            public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)
            {
                Job.Execute(chunk, unfilteredChunkIndex);
            }
        }

        [BurstCompile]
        public void OnCreate(ref SystemState state)
        {
            m_System = new CopyInputToCommandBuffer<__COMMAND_NAME__InputBufferData, __COMMAND_COMPONENT_TYPE__>();
            m_EntityQuery = m_System.Create(ref state);
        }

        public void OnDestroy(ref SystemState state)
        {
        }

        [BurstCompile]
        public void OnUpdate(ref SystemState state)
        {
            var sendJob = new CopyInputs{Job = m_System.InitJobData(ref state)};
            state.Dependency = sendJob.Schedule(m_EntityQuery, state.Dependency);
        }
    }

    // This needs to run early to ensure the input data has been applied from buffer to input data
    // struct before the input processing system runs
    [BurstCompile]
    [System.Runtime.CompilerServices.CompilerGenerated]
    [UpdateInGroup(typeof(PredictedSimulationSystemGroup), OrderFirst = true)]
    [UpdateBefore(typeof(PredictedFixedStepSimulationSystemGroup))]
    internal partial struct __COMMAND_NAME___ApplyCurrentInputBufferElementToInputDataSystem : ISystem
    {
        private ApplyCurrentInputBufferElementToInputData<__COMMAND_NAME__InputBufferData, __COMMAND_COMPONENT_TYPE__> m_System;
        private EntityQuery m_EntityQuery;

        [BurstCompile]
        public struct ApplyCurrentInput : IJobChunk
        {
            public ApplyCurrentInputBufferElementToInputData<__COMMAND_NAME__InputBufferData, __COMMAND_COMPONENT_TYPE__>.ApplyInputDataFromBufferJob Job;
            [BurstCompile]
            public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)
            {
                Job.Execute(chunk, unfilteredChunkIndex);
            }
        }

        [BurstCompile]
        public void OnCreate(ref SystemState state)
        {
            m_System = new ApplyCurrentInputBufferElementToInputData<__COMMAND_NAME__InputBufferData, __COMMAND_COMPONENT_TYPE__>();
            m_EntityQuery = m_System.Create(ref state);
        }

        public void OnDestroy(ref SystemState state)
        {
        }

        [BurstCompile]
        public void OnUpdate(ref SystemState state)
        {
            var applyJob = new ApplyCurrentInput{Job = m_System.InitJobData(ref state)};
            state.Dependency = applyJob.Schedule(m_EntityQuery, state.Dependency);
        }
    }
}

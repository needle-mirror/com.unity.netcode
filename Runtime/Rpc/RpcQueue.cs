using System;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Entities;
using Unity.Networking.Transport;

namespace Unity.NetCode
{
    /// <summary>
    /// <para>
    /// A helper struct that should be used schedule outgoing RPCs.
    /// The RpcQueue is used internally by the code-generated systems that consume the
    /// <see cref="SendRpcCommandRequest"/> requests, and allow you to serialize the rpc (that will be sent
    /// into the <see cref="OutgoingRpcDataStreamBuffer"/> for the outgoing connection).
    /// </para>
    /// <para>
    /// You can use the RpcQueue in your custom system by retrieving an instance for the given
    /// <typeparamref name="TActionRequest"/>, <typeparamref name="TActionSerializer"/> pair from the <see cref="RpcCollection"/>
    /// by calling the <see cref="RpcCollection.GetRpcQueue{TActionRequest,TActionSerializer}"/> method.
    /// </para>
    /// </summary>
    /// <remarks>
    /// If you intend to cache the retrieved queue (e.g. inside an OnCreate function in your system),
    /// you must ensure that your system is created after the <see cref="RpcSystem"/> by using the <see cref="CreateAfterAttribute"/>.
    /// </remarks>
    /// <typeparam name="TActionSerializer">The typename of the struct implementing the <see cref="IRpcCommandSerializer{T}"/> interface for the <typeparamref name="TActionRequest"/>.</typeparam>
    /// <typeparam name="TActionRequest">The typename of a struct implementing the <see cref="IComponentData"/> interface.</typeparam>
    public struct RpcQueue<TActionSerializer, TActionRequest>
        where TActionRequest : struct, IComponentData
        where TActionSerializer : struct, IRpcCommandSerializer<TActionRequest>
    {
        internal ulong rpcType;
        [ReadOnly] internal NativeParallelHashMap<ulong, int> rpcTypeHashToIndex;
        [ReadOnly] internal NativeReference<byte> dynamicAssemblyList;

        /// <summary>
        /// <para>
        /// Schedules an rpc to be sent through the network, by serializing and appending a new
        /// rpc packet into the <see cref="OutgoingRpcDataStreamBuffer"/>, for the given connection.
        /// </para>
        /// <para>
        /// The binary rpc data has the following format:</para>
        /// <para> - PacketType: short or long based on the <see cref="RpcCollection.DynamicAssemblyList"/>.</para>
        /// <para> - MsgLen: short, the length of the serialized data.</para>
        /// <para> - RpcData: the binary data generated by invoking the <typeparamref name="TActionSerializer"/> serialize method.</para>
        /// </summary>
        /// <param name="buffer">Stream buffer for the rpc packetsk</param>
        /// <param name="ghostFromEntity">Lookup for ghost instance</param>
        /// <param name="data">data</param>
        /// <exception cref="InvalidOperationException">If the RPC index cannot be found for the rpc type.</exception>
        public unsafe void Schedule(DynamicBuffer<OutgoingRpcDataStreamBuffer> buffer,
            ComponentLookup<GhostInstance> ghostFromEntity, TActionRequest data)
        {
            var serializer = default(TActionSerializer);
            // TODO - Expose a user-configurable StreamCompressionModel for both RPCs and ghosts, and hook it up here.
            var serializerState = new RpcSerializerState
            {
                GhostFromEntity = ghostFromEntity,
                CompressionModel = StreamCompressionModel.Default,
            };
            var msgHeaderLenBytes = RpcCollection.GetInnerRpcMessageHeaderLength(dynamicAssemblyList.Value == 1);
            int maxSizeBytes = UnsafeUtility.SizeOf<TActionRequest>() + msgHeaderLenBytes + 1;
            int rpcIndex = 0;
            if (!(dynamicAssemblyList.Value == 1) && !rpcTypeHashToIndex.TryGetValue(rpcType, out rpcIndex))
                throw new InvalidOperationException($"Could not find RPC index for type '{rpcType}'!");
            while (true)
            {
                DataStreamWriter writer = new DataStreamWriter(maxSizeBytes, Allocator.Temp);
                if (dynamicAssemblyList.Value == 1)
                    writer.WriteULong(rpcType);
                else
                    writer.WriteUShort((ushort)rpcIndex);

                var lenWriter = writer;
                writer.WriteUShort((ushort)0);

#if ENABLE_UNITY_COLLECTIONS_CHECKS
                UnityEngine.Debug.Assert(writer.Length == RpcCollection.GetInnerRpcMessageHeaderLength(dynamicAssemblyList.Value == 1));
#endif

                serializer.Serialize(ref writer, serializerState, data);

                if (!writer.HasFailedWrites)
                {
                    // If this RPC is delta-compressed (supported in 1.3), then we MUST flush (ceil to byte),
                    // and we MUST store the RPC length in bits.
                    var rpcDataSizeBits = (writer.LengthInBits - (msgHeaderLenBytes * 8));
                    writer.Flush();

                    // Note: 8KiB for one RPC is obviously absurd, but it's transports job (via BeginSend) to tell us
                    // what our max packet size is (via the `RpcSystem`), AND users can opt-into fragmentation.
                    if (rpcDataSizeBits > ushort.MaxValue)
                        throw new InvalidOperationException($"Individual RPC (of type {ComponentType.ReadOnly<TActionRequest>().ToFixedString()}) is too large to serialize into the RpcQueue! It is {rpcDataSizeBits} bits [8192 bytes], which is greater than ushort.MaxValue of {ushort.MaxValue}!");
                    lenWriter.WriteUShort((ushort) rpcDataSizeBits);

                    var prevLen = buffer.Length;
                    var desiredLength = buffer.Length + writer.Length;
                    buffer.ResizeUninitialized(desiredLength);
                    byte* ptr = (byte*) buffer.GetUnsafePtr();
                    ptr += prevLen;
                    UnsafeUtility.MemCpy(ptr, writer.AsNativeArray().GetUnsafeReadOnlyPtr(), writer.Length);
                    break;
                }
                maxSizeBytes *= 2;
            }
        }
    }
}

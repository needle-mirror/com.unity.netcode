{
  "name": "com.unity.netcode",
  "displayName": "Netcode for Entities",
  "version": "1.3.2",
  "unity": "2022.3",
  "unityRelease": "11f1",
  "description": "Unity's Data Oriented Technology Stack (DOTS) multiplayer netcode layer - a high level netcode system built on entities. This package provides a foundation for creating networked multiplayer applications within DOTS.",
  "dependencies": {
    "com.unity.transport": "2.2.1",
    "com.unity.entities": "1.3.2",
    "com.unity.modules.animation": "1.0.0"
  },
  "_upm": {
    "changelog": "### Changed\n * Updated entities packages dependencies\n\n### Added\n\n* Significantly reduced bandwidth consumption of command packets (i.e. input packets), by a) converting the first command payload in each packet to use delta-compression against zero, b) by making the number of commands sent (per-packet) tied to the `TargetCommandSlack`, c) by delta-compressing the NetworkTicks using the assumed previous tick (which is a correct assumption in the common case), and d) by using a single `changeBit` if the previous command is exactly the same.\n* `ClientTickRate.NumAdditionalCommandsToSend` is a new field allowing you to configure how many additional commands to send to the server in each command (i.e. input) packet.\n* Support for dumping input commands into the `NetDebugPacket` dump, helping users visualize and diagnose bandwidth consumption. Implement the optional, burst-compatible method `ToFixedString` on your input components to see field data in your packet dumps, too.\n* A `NetworkSnapshotAck.CommandArrivalStatistics` struct, documenting (on the server, for each client) how many commands arrive, and how many commands arrive too late. These statistics can be used to inform and tweak `TargetCommandSlack` and `NumAdditionalCommandsToSend`.\n* Significantly expanded our automated test coverage for Lag Compensation. We now detect off-by-one-tick errors between the client and server's lag compensation resolutions.\n* `LagCompensationConfig.DeepCopyDynamicColliders` (defaulting to true) and `LagCompensationConfig.DeepCopyStaticColliders` (defaulting to false) configuration values, enabling you to control whether or not colliders are deep copied during world cloning, preventing runtime exceptions when querying historic worlds during Lag Compensation. Also see the specialized `PhysicsWorldHistorySingleton.DeepCopyRigidBodyCollidersWhitelist` collection.\n\n### Changed\n\n* `PhysicsWorldHistory` now clones collision worlds *after* the `BuildPhysicsWorld` step for the given `ServerTick`. This fixes an issue where the `CollisionWorld` returned by `GetCollisionWorldFromTick` is off-by-one on the server. It is now easier to reason about, as the data stored for `ServerTick` T now actually corresponds to the `BuildPhysicsWorld` operation that occurred on tick T (rather than T-1, which was the previous behaviour). We strongly recommend having automated testing for lag compensation accuracy, as this may introduce a regression, and is therefore a minor breaking change.\n* `PhysicsWorldHistory` now deep copies dynamic colliders by default (see fix entry). Performance impact should be negligible.\n\n### Fixed\n\n* Corrected `seealso` usage in XML package documentation.\n* Documentation improvements and clarifications on the following pages: command stream, ghost snapshots, spawning ghosts, logging, network connection, networked cube, prediction, and RPCs.\n* Lag Compensation issue in the case where an Entity - hit by a query against a historic lag compensation `CollisionWorld` fetched via `GetCollisionWorldFromTick` - has since been deleted. The colliders of dynamic ghosts are now deep cloned by default, preventing the blob asset assertions which would have otherwise been encountered here. You can also opt-into copying static colliders via the `LagCompensationConfig` or `NetCodePhysicsConfig` authoring (although the recommendation is to instead query twice; once against static geometry exclusively, using the latest collision world, then again using the hit position of the static query, against lag compensated dynamic entities).\n* Issue where non-power-of-2 History Buffer sizes would return incorrect entries when `ServerTick` wraps around.\n* an issue with iOS and WebGL AOT, causing the player throwing exceptions while trying to initialize the Netcode generated ghost serializer function pointers. The issue is present when using Burst 1.8 and Unity 6.0+\n* an issue with GhostGroup serialization, incorrectly accessing the wrong ghost prefab type in the GhostCollectionPrefab array.\n* an issue with buffer serialization when using GhostGroup, causing memory stomping at runtime (and exception thrown in the editor), due to the fact the required size for storing the buffer in the snapshot was calculated incorrectly. The root cause was the incorrect index used to access the GhostCollectionPrefab collection."
  },
  "upmCi": {
    "footprint": "e5b1dca67670175eeaa61f4876150e1f0d88af18"
  },
  "documentationUrl": "https://docs.unity3d.com/Packages/com.unity.netcode@1.3/manual/index.html",
  "repository": {
    "url": "https://github.cds.internal.unity3d.com/unity/dots.git",
    "type": "git",
    "revision": "921920e681054c59b440cc1e2aef10f781dc4124"
  }
}

{
  "name": "com.unity.netcode",
  "displayName": "Netcode for Entities",
  "version": "1.3.0-exp.1",
  "unity": "2022.3",
  "unityRelease": "11f1",
  "description": "Unity's Data Oriented Technology Stack (DOTS) multiplayer netcode layer - a high level netcode system built on entities. This package provides a foundation for creating networked multiplayer applications within DOTS.",
  "dependencies": {
    "com.unity.transport": "2.2.0",
    "com.unity.entities": "1.3.0-exp.1",
    "com.unity.modules.animation": "1.0.0"
  },
  "_upm": {
    "changelog": "### Added\n\n* The Multiplayer PlayMode Tools Window now calls synchronous `Connect` and `Disconnect` methods, and now shows the `Handshake` connection step. Handshake occurs when the client connection has been accepted by the server, but said client is awaiting a `NetworkId` assignment RPC from said server.\n* Possibility to optimise the ghost serialization and pre-serialization by registering a custom chunk serialization function pointer that will let users reason on a per-archetype and write the serialization code without requiring virtual methods (function pointer call indirection) and optimised for the use case.\n* Further clarifications, minor improvements, and fixes to the PlayMode Tools Window.\n* `DefaultRelevancyQuery` to specify general rules for relevancy without specifying it ghost by ghost.\n* Tooltips and additional info for the NetCodeConfig, supporting `ClientServerTickRate`, `ClientTickRate`, and `GhostSendSystemData`.\n* Method `EnablePacketLogging.LogToPacket`, allowing user-code to add custom events to the netcode per-connection packet dump.\n* An optional connection approval procedure so you can validate that a connection is allowed to connect before a network ID is assigned to it. Connection Approval requests can be sent by client to server via an IApprovalRpcCommand RPC. The server can validate the arbitrary payload included in the RPC. No other data is processed by the server until the connection is approved.\n* More documentation on prediction, edge cases to be careful about, interpolation, compression, physics ghost setup checklist and the general update loop.\n* Increased validation applied to RPC serialization (including better error logging). We now ensure their deserialized size is the expected number of bytes.\n* Test coverage for `windowSize: 64` for `ReliableSequencedPipelineStage`.\n* PredictedSpawnedGhostRollbackToSpawnTick property to the GhostAuthoringComponent to allow predicted ghost spawned by client to rollback and re-simulate their state starting from their spawn tick, until the authoritative spawn has been received from the server. The rollback only occurs if the client receives new snapshots from server that contains at least one predicted ghost.\n* Changed usage of NetworkParameterConstants.MTU to use user configurable NetworkParameterConstants.MaxMessageSize. This allows snapshot and command buffers to reference the correct value and scale buffers accordingly.\n* Exposed `NetworkStreamDriver.DriverStore` and `LastEndPoint`.\n* Copy-free accessors for `NetworkStreamDriver` instances (via `GetDriverInstanceRW` and `GetDriverInstanceRO`) and underlying drivers (via `GetDriverRW` and `GetDriverRO`), which are also now used internally. The struct copy originals have been weakly deprecated.\n* Support for serializing non-byte-aligned RPCs. I.e. You can now delta-compress RPC fields using the `IRpcCommandSerializer` by delta-compressing against hardcoded baseline values.\n\n### Changed\n\n* Added the full type name of the RPC component to the RPC entity name (behind \"NetcodeRPC_\" prefix).\n* The netcode RPC header size has now changed (from 9B to 5B per packet, plus either 10B or 4B per RPC, depending on `DynamicAssemblyList`).\n* The max size of a serialized RPC is now 8192 bytes (ushort.MaxValue bits), as we now send the bits written, to be able to validate that the exact number of bits were read in the `RpcSystem`.\n* Reduced bandwidth consumption of netcode's `RpcSetNetworkId` RPC payload.\n* Updated `com.unity.transport` dependency to version 2.2.0.\n* Fixed another issue with predicted ghosts spawned again inside the prediction loop, not rolling back to the backup or re-predicting from the spawn tick, after being initialized by the PredictedSpawnGhostSystem (because of command buffer delay), effectively mispredicting again the first full tick and subsequent partial, and making the backup also contain mispredicted information.\n* Renamed `RpcSetNetworkId` to `ServerApprovedConnection`.\n* The servers `Handshake` process is no longer instantaneous, resulting in a few extra ticks being required (typically) before a connection can be fully established (approximately 7 ticks, up from 4). See bug fix entry.\n* `NetCodeConnectionEvent`s are now raised on the server for the protocol version handshake process (the `ConnectionState.State.Handshake` enum value). See bug fix entry.\n* Reduced bandwidth consumption of netcode's `NetworkProtocolVersion` RPC.\n\n### Removed\n\n* NoScale function delegate.\n\n### Fixed\n\n* Compile error when having both com.unity.netcode and com.unity.dedicated-server package together.\n* Issue where disconnecting your own client (via a direct `Disconnect` call) would fail to recycle the `NetworkId` component, and fail to dispose of the Entity.\n* We now also correctly report and clean-up stale connections. I.e. Connections that are entered into invalid states by user-code.\n* Issue where the `CommandSendSystem` was attempting to send RPCs with stale connections.\n* some slow path in the normal ghost serialization that was causing many re-serialization of the same chunk, in case the chunk data was not fitting inside the temporary stream buffer. That was almost the norm in many cases, when the serialised entities are large enough (either because of the number of components or because of the size of them).\n* NetworkStreamConnection now holds an accurate connection state right after the call to driver's Connect, instead of having to wait a frame to get it updated.\n* Minor documentation issues.\n* InvalidOperationException: cases where EntityManager is part of an exclusive transaction we skip gathering analytics for its world.\n* Breaking change where NoScale function was removed.\n* Issue where the `NetCodeDebugConfig` would not reset to the `LogLevel` default (of `Notify`) if toggled ON, changed, then toggled OFF, during playmode.\n* Minor documentation errors and improving overall grammar.\n* Issue where `NetCodeConfig.Global` did not load correctly on first boot, if not selected in the Project assets window. If you have a global `NetCodeConfig` set in your PreloadedAssets Project Setting, we'll also auto-upgrade your project, moving the save to Project Settings (via `NetCodeClientAndServerSettings`).\n* Negative network delta time will skip updating the system group.\n* `NETCODE_NDEBUG` define compiler error, and related missing documentation.\n* Issue where two IInputComponentData with the same name but in different namespaces would result in conflicted generated code. Namespace is now taken into account for source gen.\n* Network emulation tooltip clarification.\n* Off-by-one error causing RPCs sent on the same tick as the `ProtocolVersion` RPC to be corrupted.\n* Language improvements to PredictedSimulationSystemGroup and ClientServerBootstrap.\n* Performance problems with GhostCollectionSystem, with large number of prefabs.\n* PredictedGhostSpawnSystem incorrectly set the offset for serialized buffer data inside the snapshot buffer, making that incompatible with the GhostUpdateSystem logic and causing wrong data potentially copied back to the entity buffer.\n* An issue with preserialized ghost, that were stomping component data with incorrect values.\n* an issue in GhostUpdateSystem that was incorrectly handling the GhostComponentAttribute.SendToOwner flag, causing during continuation and partial ticks replicated data being overwritten incorrectly for predicted ghosts.\n* An issue due to structural changes, that was causing a large number of prediction step performed by the client due to the fact a given ghost could not continue the current prediction from the last full ticks (either partial ticks or another full tick) because the entity data could not be found anymore in the prediction history buffer.\n* Issue where RPCs appeared on deleted connection entities, leading to user code runtime exceptions, where, occasionally, the `NetworkId` component could not be found on the `ReceiveRpcCommandRequest.SourceConnection` (as the connection was already disconnected).\n* the client was acknowledging to the server only the last received snapshot instead of the last 32 (this was used to defeat packet loss). This was affecting both the ability to correct use all the available baseline for delta compression, and multiple re-sending static optimized ghost.\n* Rendering issue in `GhostAuthoringInspectionComponent`, causing UI to right-clip.\n* Defensive fix for other rendering issue in `GhostAuthoringInspectionComponent`, causing the Refresh and auto-refresh buttons to not appear correctly.\n* Fixed check to early release allocations in the case where a ghost chunk has been reused. We now correctly free these chunks, reducing allocated memory overhead on the server.\n* Rotation glitch issue with prediction switching interpolation\n* Issue where RTT calculation would be incorrectly high when first connecting, especially with high packet loss.\n* Issue where running a netcode test would invalidate the `NetworkTimeSystem.TimestampMS` for subsequent play-mode runs, when Domain Reloads are disabled, leading to `0Â±0` ping readout (and related issues).\n* an issue with predicted spawned ghost and enableable components state not being saved correctly in the snapshot buffer when the PredictedSpawnGhostRequest is processed and the entity initialized.\n* an issue with pre-spawned ghost and enableable components state not being saved correctly in the predicted spawn baseline buffer.\n* exception thrown by the `GhostPresentationGameObjectSystem` when an entity is destroyed. The system was accessing the tracked `GameObject` list using an invalid index in cases where the removed `GameObject` was the last element.\n* Exceptionally rare infinite loop crash in `SetupDataAndAvailableBaselines`.\n* an issue in the PredictedGhostHistorySystem, that was storing the backup of newly spawned ghost using the wrong ghost type and serializer. It was causing weird problem later in the GhostUpdateSystem, in case predicted spawned ghost are eligible to start re-simulating from the spawn tick. In particular, crashes, big memory allocation or other component data could be clobbered with invalid data.\n* an issue with predicted spawned not restored from backup correctly whence spawned immediately at the tick they are supposed to (no command buffer) inside a system executing in the prediction loop (using the IsFirstTimePredictedTick condiition). The snapshot data at spawn, that is initialized the next frame, it is not going to be a full tick, but a partial tick, causing more misprediction. The backup in general should be preferred in this case, because at least it is aligned with the last full tick.\n* broken multiphysics sample particles colliding with the player character only on the client (they are supposed to be only visual) because of a missing WorldIndex authoring component.\n* `IRpcCommandSerializer<T>` can now be used with structs implementing `IRpcCommand` and `IApprovalRpcCommand` (rather than just `IComponentData`). I.e. The limitation is restricted, and code-gen will handle this case correctly (by skipping the generation of the RPC systems and serializer).\n* We now (correctly) wait for the server to receive a valid protocol version from the client before moving said client from the `Handshake` state to the `Connected` state. Therefore; `Handshake` events are now correctly raised on the server.\n* The protocol version handshake process can now correctly timeout (see: `HandshakeApprovalTimeoutMS`) in the exceptional case where the server does not receive a `RequestProtocolVersionHandshake` RPC from the client. If the approval flow is enabled, this single timeout counter is used for both states.\n* Removed the hardcoded 'Protocol Version' RPC logic, simplifying RPC sending and receiving. Netcode's handshake RPCs now use the existing `IApprovalRpcCommand` flows."
  },
  "upmCi": {
    "footprint": "f9c50a7c07f7b59c52e6dcfacbc808c0d7736473"
  },
  "documentationUrl": "https://docs.unity3d.com/Packages/com.unity.netcode@1.3/manual/index.html",
  "repository": {
    "url": "https://github.cds.internal.unity3d.com/unity/dots.git",
    "type": "git",
    "revision": "d5bde5f043ad76defc80bbc6be1f8630d14b108d"
  }
}
